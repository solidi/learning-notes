# Facts and Fallacies of Software Engineering
## Author: Robert L. Glass

## Tips

### About Management
1. The most important factor in software work is the quality of the programmers.
2. The best programmers are up to 28 times better than the worst programmers.
3. Adding people to a late project makes it later.
4. The working environment has a profound impact on productivity and quality.

### Tools and Techniques

5. Hype (about tools and techniques) is the plague on the house of software.
6. New tools and techniques cause an initial *loss* of productivity/quality.
7. Software developers talk a lot about tools, but seldom use them.

### Estimation
8. One of the two most common causes of runaway projects is poor estimation.
9. Software estimation usually occurs at the wrong time.
10. Software estimation is usually done by the wrong people.
11. Software estimates are rarely corrected as the project proceeds.
12. It is not surprising that software estimates are bad. But we live and die by them anyway.
13. There is a disconnect between software management and their programmers.
14. The answer to a feasibility study is almost always "yes."

### Reuse
15. Reuse-in-the-small is a well-solved problem.
16. Reuse-in-the-large remains a mostly unsolved problem.
17. Reuse-in-the-large works best in families of related systems.
18. Reusable components are three times as hard to build and should be tired out in three settings.
19. Modification of reused code is particularly error-prone.
20. Design pattern reuse is one solution to the problems of code reuse.

### Complexity
21. For every 25 percent increase in problem complexity, there is a 100 percent increase in solution complexity.
22. Eighty percent of software work is intellectual. A fair amount of it is creative. Little of it is clerical.

### Requirements
23. One of the two most common causes of runaway projects is unstable requirements.
24. Requirements errors are the most expensive to fix during production.
25. Missing requirements are the hardest requirements errors to correct.

### Design
26. Explicit requirements "explode" as implicit (design) requirements for a solution evolve.
27. There is seldom one best design solution to a software problem.
28. Design is a complex, iterative process. Initial design solutions are usually wrong and certainly not optimal.

### Coding
29. Designer "primitives" (solutions programmers can readily code) rarely match programmer "primitives."
30. COBOL is a very bad language, but all the others (for business applications) are so much worse.

### Removal
31. Error removal is the most time-consuming phase of the life cycle.

### Testing
32. Software is usually tested at best at the 55 to 60 percent (branch) coverage level.
33. One hundred percent coverage is still far from enough.
34. Test tools are essential, but many are rarely used.
35. Test automation rarely is. Most testing activities cannot be automated.
36. Programmer-created, built-in debug code is an important supplement to testing tools.

### Reviews and Inspections
37. Rigorous inspections can remove up to 90 percent of errors before the first test case is run.
38. Rigorous inspections should not replace testing.
39. Postdelivery reviews (some call them "retrospectives") are important and seldom performed.
40. Reviews are both technical and sociological, and both factors must be accommodated.

### Maintenance
41. Maintenance typically consumes 40 to 80 percent of software costs. It is probably the most important life cycle phase of software.
42. Enhancements represent roughly 60 percent of maintenance costs.
43. Maintenance is a solution, not a problem.
44. Understanding the existing product is the most difficult task of maintenance.
45. Better methods lead to more maintenance, not less.

### Quality
46. Quality is a collection of attributes.
47. Quality is not user satisfaction, meeting requirements, achieving cost and schedule, or reliability.

### Reliability
48. There are errors that most programmers tend to make.
49. Errors tend to cluster.
50. There is no single best approach to software error removal.
51. Residual errors will always persist. The goal should be to minimize or eliminate serve errors.

### Efficiency
52. Efficiency stems more from good design than good coding.
53. High-order language code can be about 90 percent as efficient as comparable assembler code.
54. There are tradeoffs between size and time optimization.

### Research
55. Many researches advocate rather than investigate.
